environ

 vocabularies SUBSET_1, NUMBERS, XBOOLE_0, FUNCOP_1, FUNCT_2, RELAT_1, TARSKI,
      FINSEQ_1, CARD_3, FUNCT_1, ZFMISC_1, ORDINAL4, CARD_1, XBOOLEAN,
      MARGREL1, PARTFUN1, NAT_1, UNIALG_1, FINSEQ_2, UNIALG_2, LEIBNIZ, ARYTM_3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, RELAT_1,
      NAT_1, RELSET_1, FUNCT_2, XBOOLEAN, MARGREL1, CARD_3, FINSEQ_1, FINSEQ_2, FUNCOP_1, PARTFUN1;
 constructors FUNCOP_1, XCMPLX_0, FINSEQ_1, XBOOLEAN, RELSET_1, CARD_3,
      FINSEQ_2, MARGREL1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, XBOOLEAN, FINSEQ_1,
      FINSEQ_2, ORDINAL1, RELSET_1, PARTFUN1, FUNCOP_1, XXREAL_0, CARD_1,
      CARD_3, MARGREL1;
 requirements SUBSET, BOOLE, ARITHM;
 definitions TARSKI, XBOOLE_0, XBOOLEAN, FINSEQ_1, CARD_3, FUNCT_1, FUNCOP_1, MARGREL1;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, FUNCT_2, FUNCOP_1, XBOOLE_0, XBOOLE_1,
      XBOOLEAN, FUNCT_1, CARD_3, FINSEQ_3, RELAT_1, RELSET_1, PARTFUN1,
      ORDINAL1, FINSEQ_2, MARGREL1;
 schemes XBOOLE_0, FUNCT_1;


begin

:: Object theory models consist of 7 pieces of data:
::
:: * A non-empty set of objects;
:: * A non-empty set of points;
:: * A set of properties, which are relations on the objects;
:: * An exemplification relation holding between objects and properties;
:: * An encoding relation, holding between objects and properties;
:: * A distinguished subset of objects (the concrete ones).

definition
struct ObjectTheoryModel
  (#
    objects -> non empty set,
    points -> non empty Subset of the objects,
    propositions -> set,
    properties -> Subset of (the objects)*,
    exemplificationRelation -> Relation of the objects, the properties,
    encodingRelation -> Relation of [:the objects, the points:],
                                    (the properties \/ the propositions),
    trueAtRelation -> Function of the propositions, the points,
    actualWorld -> Element of the points,
    concreteObjects -> Subset of [: the objects, the points :],
    abstractionOperation -> Function of the propositions, the properties
  #);
end;

:: Convenient types coming from the slots of ObjectTheoryModel
:: structures

definition
  let M be ObjectTheoryModel;
  mode
    Object of M
  means
    :DefObjectOf:
    it in the objects of M;
  existence;
end;

definition
  let M be ObjectTheoryModel;
  mode
    Point of M -> Object of M
  means
    :DefPointOf:
    it in the points of M;
  existence;
  mode
    Property of M
  means
    :DefPropertyOf:
    it in the properties of M;
  existence;
  mode
    Proposition of M
  means
    :DefPropositionOf:
    it in the propositions of M;
  existence;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Worlds
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let M be ObjectTheoryModel,
      d be Point of M,
      p be Proposition of M;
  pred
    p is_true_at d
  means
    :DefTrueAt:
    [d,p] in the trueAtRelation of M;
end;

definition
  let M be ObjectTheoryModel,
      p be Proposition of M,
      a be Object of M,
      d be Point of M;
  pred
    a exemplifies_at p,d
  means
    :DefExemplificationOfProposition:
    [[a,d],p] in the exemplificationRelation of M;
  pred
    a encodes_at p,d
  means
    :DefEncodingOfProposition:
    [[a,d],p] in the encodingRelation of M;
end;

definition
  let M be ObjectTheoryModel,
      p be Property of M,
      a be Object of M,
      d be Point of M;
  pred
    a exemplifies_at p,d
  means
    :DefExemplificationOfProperty:
    [[a,d],p] in the exemplificationRelation of M;
  pred
    a encodes_at p,d
  means
    :DefEncodingOfProperty:
    [[a,d],p] in the encodingRelation of M;
end;

definition
  let M be ObjectTheoryModel,
      p be Proposition of M;
  func
    lambda(p) -> Property of M
  means
    :DefLambda:
    [p,it] in the abstractionOperation of M;
  existence;
  uniqueness;
end;

definition
  let M be ObjectTheoryModel,
      d be Point of M,
      p be Proposition of M;
  pred
    d validates p
  means
    :DefValidates:
    d encodes_at lambda(p),d;
end;

definition
  let M be ObjectTheoryModel;
  mode
    World of M -> Point of M
  means
    :DefWorld:
    ex d being Point of M st
      for p being Proposition of M holds
        (it encodes_at p,d iff p is_true_at it);
  existence;
end;

:: Concrete, ordinary and abstract objects
definition
  let M be ObjectTheoryModel,
      a be Object of M,
      d be Point of M;
  pred
    a is_concrete_at d
  means
    :DefConcreteAt:
    a in the concreteObjects of M;
end;

definition
  let M be ObjectTheoryModel,
      a be Object of M;
  attr
    a is ordinary
  means
    :DefOrdinary:
    ex w being World of M st a is_concrete_at w;
end;
    

notation
  let M be ObjectTheoryModel,
      a be Object of M;
  antonym a is abstract for a is ordinary;
end;

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Properties and propositions
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let M be ObjectTheoryModel;
  attr
    M is fully-abstract
  means
    :DefFullyAbstract:
    for x being Object of M holds x is abstract;
  attr
    M is fully-concrete
  means
    :DefFullyConcrete:
    for x being Object of M ex d being Point of M st x is_concrete_at d;
end;

registration
  let M be ObjectTheoryModel;
  cluster abstract for Object of M; :: there is always at least one abstract object
  existence;
end;

registration
  cluster non fully-abstract for ObjectTheoryModel;
  existence;
end;

registration
  cluster non fully-concrete for ObjectTheoryModel;
  existence;
end;

:: Appendix III: The Basic Theorems of World Theory

:: Definition of the makes-true relation

:: 1. There is a unique actual world

:: 2. Every world is maximal

:: 3. Every world is possible

:: 4. Every world is modally closed

:: 5. A proposition is necessarily true iff it is true at all possible
::    worlds

:: 6. A proposition is possible iff there is a world where it is true

:: 7. For any object x: a proposition p is true at world w if and only
:: if at w, x exemplifies being such that p

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: "A (Leibnizian) theory of concepts"
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Priciple 1
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

registration
  let M be non fully-abstract ObjectTheoryModel;
  cluster ordinary for Object of M;
  existence;
end;

theorem Principle1:
for M being non fully-abstract ObjectTheoryModel,
    a being ordinary Object of M,
    d being Point of M
  holds not (ex F being Property of M st a encodes_at F,d);

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Principle 2, as a definition
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let M be ObjectTheoryModel,
      x, y be Object of M;
  pred x =E y
  means :DefConcreteEquality:
    for w being World of M,
        F being Property of M
      holds ( x exemplifies_at F,w iff y exemplifies_at F,w);
end;

:: Principle 3, as a scheme

:: We'll probably run into trouble with the absence of a contraint on
:: free variables.  But then again, we'd run into a trouble with
:: replacement, too, wouldn't we?  How do we skirt that issue?
scheme Principle3 { M() -> non fully-concrete ObjectTheoryModel,
                    P[Property of M()] } :
    ex x being abstract Object of M() st
      for w being World of M(), :: is this where the quantifier belongs?
          F being Property of M() holds (x encodes_at F,w iff P[F])
proof
  thus thesis;
end;

:: Principle 4, as a definition
definition
  let M be ObjectTheoryModel,
      x, y be Object of M;
  pred x =A y means
  :DefAbstractEquality:
  for w being World of M,
      F being Property of M
    holds (x encodes_at F,w iff y encodes_at F,w);
end;

:: Principle 5
definition
  let M be ObjectTheoryModel,
    x, y being Object of M;
  redefine pred
    x = y
  means
    :DefObjectEquality:
    x =A y or y =E y;
  compatibility;
end;

:: Principle 6, as a scheme
::
:: not sure how to represent this
::
:: scheme
::   Principle6 { M() -> ObjectTheoryModel, x,y() -> Object of M() }:
::     x = y
::   provided
::     :: ...

:: Logic of encoding
theorem LogicOfEncoding:
for M being ObjectTheoryModel,
    x being Object of M,
    F being Property of M
  st    (ex  w being World of M st    x encodes_at F,w)
  holds (for w being World of M holds x encodes_at F,w);

definition
  let M be ObjectTheoryModel,
      a be Object of M,
      F be Property of M;
  pred
    a encodes F
  means
    ex w being World of M st a encodes_at F,w;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::: Theorems
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  struct (ObjectTheoryModel) LeibnizConceptModel
    (# objects -> non empty set,
       points -> non empty Subset of the objects,
       propositions -> set,
       properties -> Subset of (the objects)*,
       exemplificationRelation -> Relation of the objects, the properties,
       encodingRelation -> Relation of [:the objects, the points:],
                                       (the properties \/ the propositions),
       trueAtRelation -> Function of the propositions, the points,
       actualWorld -> Element of the points,
       concreteObjects -> Subset of [: the objects, the points :],
       abstractionOperation -> Function of the propositions, the properties,
       entailsRelation -> Relation of the objects, the objects #);
end;

notation
  let M be LeibnizConceptModel,
      x be Object of M;
  synonym x is concept for x is abstract;
end;

registration
  let M be LeibnizConceptModel;
  cluster abstract for Object of M;
  existence;
end;

definition
  let M be LeibnizConceptModel;
  mode Concept of M is abstract Object of M;
  correctness;
end;

definition
  let M be LeibnizConceptModel;
  redefine mode Property of M -> Concept of M;
  coherence;
end;

definition
  let M be LeibnizConceptModel;
  let c be Concept of M;
  let d be Concept of M;
  pred
    c entails d
  means
    :DefEntails:
    [c,d] in the entailsRelation of M;
end;

reserve M for LeibnizConceptModel,
        x, y, z for Object of M,
        F, G, H for Property of M;

theorem Theorem1:
x = x; :: proof is obvious

theorem Theorem2:
x = y implies y = x;

theorem Theorem3:
(x = y & y = z) implies x = z;

:: The concept-of operator
definition
  let M be LeibnizConceptModel;
  let G be Property of M;
  func
    concept_of(G) -> Concept of M
  means
    :DefConceptOf:
    for F being Property of M holds (it encodes F iff G entails F);
  existence;
  uniqueness;
end;

:: Concept sum
definition
  let M be LeibnizConceptModel,
      x, y be Concept of M;
  func
    x + y -> Concept of M
  means
    :DefConceptSum:
    for F being Property of M
     holds it encodes F iff (x encodes F or y encodes F);
  existence;
  uniqueness;
end;

theorem Theorem4Part1:
concept_of(G) + concept_of(H) is Concept of M; :: obvious

theorem Theorem4Part2:
(concept_of(G) + concept_of(H)) encodes F implies (G entails F or H entails F)
proof
  set cG = concept_of(G);
  set cH = concept_of(H);
  set S = cG + cH;
  thus S encodes F implies (G entails F or H entails F)
  proof
    assume A1: S encodes F;
    then for F being Property of M
      holds S encodes F iff (cG encodes F or cH encodes F) by DefConceptSum;
    then S encodes F iff (cG encodes F or cH encodes F);
    then cG encodes F or cH encodes F by A1;
    then per cases;
    suppose cG encodes F;
      then G entails F by DefConceptOf;
      hence thesis;
    end;
    suppose cH encodes F;
      then H entails F by DefConceptOf;
      hence thesis;
    end;
  end;
end;

theorem Theorem4Part3:
(G entails F or H entails F) implies (concept_of(G) + concept_of(H)) encodes F
proof
  set cG = concept_of(G);
  set cH = concept_of(H);
  assume A1: G entails F or H entails F;
  then per cases;
  suppose G entails F;
    then cG encodes F by DefConceptOf;
    hence thesis by DefConceptSum;
  end;
  suppose H entails F;
    then cH encodes F by DefConceptOf;
    hence thesis by DefConceptSum;
  end;
end;

theorem Theorem4Part4:
(concept_of(G) + concept_of(H)) encodes F iff (G entails F or H entails F)
  by Theorem4Part2,Theorem4Part3;


theorem Theorem4Part3:
(for F being Property of M holds (x encodes F iff (G entails F or H entails F)))
  implies (x = concept_of(G) + concept_of(H))
proof
  assume A1: for F being Property of M
               holds (x encodes F iff G entails F or H entails F);
  

        

