environ

 vocabularies SUBSET_1, NUMBERS, XBOOLE_0, FUNCOP_1, FUNCT_2, RELAT_1, TARSKI,
      FINSEQ_1, CARD_3, FUNCT_1, ZFMISC_1, ORDINAL4, CARD_1, XBOOLEAN,
      MARGREL1, PARTFUN1, NAT_1, UNIALG_1, FINSEQ_2, UNIALG_2, LEIBNIZ, ARYTM_3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, RELAT_1,
      NAT_1, RELSET_1, FUNCT_2, XBOOLEAN, MARGREL1, CARD_3, FINSEQ_1, FINSEQ_2, FUNCOP_1, PARTFUN1;
 constructors FUNCOP_1, XCMPLX_0, FINSEQ_1, XBOOLEAN, RELSET_1, CARD_3,
      FINSEQ_2, MARGREL1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, XBOOLEAN, FINSEQ_1,
      FINSEQ_2, ORDINAL1, RELSET_1, PARTFUN1, FUNCOP_1, XXREAL_0, CARD_1,
      CARD_3, MARGREL1;
 requirements SUBSET, BOOLE, ARITHM;
 definitions TARSKI, XBOOLE_0, XBOOLEAN, FINSEQ_1, CARD_3, FUNCT_1, FUNCOP_1, MARGREL1;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, FUNCT_2, FUNCOP_1, XBOOLE_0, XBOOLE_1,
      XBOOLEAN, FUNCT_1, CARD_3, FINSEQ_3, RELAT_1, RELSET_1, PARTFUN1,
      ORDINAL1, FINSEQ_2, MARGREL1;
 schemes XBOOLE_0, FUNCT_1;


begin

:: Object theory models consist of 7 pieces of data:
::
:: * A non-empty set of objects;
:: * A non-empty set of points;
:: * A set of properties, which are relations on the objects;
:: * An exemplification relation holding between objects and properties;
:: * An encoding relation, holding between objects and properties;
:: * A distinguished subset of objects (the concrete ones).

definition
struct ObjectTheoryModel
  (#
    objects -> non empty set,
    points -> non empty Subset of the objects,
    propositions -> set,
    properties -> Subset of (the objects)*,
    exemplificationRelation -> Relation of the objects, the properties,
    encodingRelation -> Relation of [:the objects, the points:],
                                    (the properties \/ the propositions),
    trueAtRelation -> Function of the propositions, the points,
    actualWorld -> Element of the points,
    concreteObjects -> Subset of [: the objects, the points :],
    abstractionOperation -> Function of the propositions, the properties
  #);
end;

:: Convenient types coming from the slots of ObjectTheoryModel
:: structures

definition
  let M be ObjectTheoryModel;
  mode
    Object of M
  means
    :DefObjectOf:
    it in the objects of M;
  existence;
::>       *4
end;

definition
  let M be ObjectTheoryModel;
  mode
    Point of M -> Object of M
  means
    it in the points of M;
  existence;
::>       *4
  mode
    Property of M
  means
    :DefProperty:
    it in the properties of M;
  existence;
::>       *4
  mode
    Proposition of M
  means
    it in the propositions of M;
  existence;
::>       *4
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Worlds
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let M be ObjectTheoryModel,
      d be Point of M,
      p be Proposition of M;
  pred
    p is_true_at d
  means
    :DefTrueAt:
    [d,p] in the trueAtRelation of M;
end;

definition
  let M be ObjectTheoryModel,
      p be Proposition of M,
      a be Object of M,
      d be Point of M;
  pred
    a exemplifies_at p,d
  means
    [[a,d],p] in the exemplificationRelation of M;
  pred
    a encodes_at p,d
  means
    [[a,d],p] in the encodingRelation of M;
end;

definition
  let M be ObjectTheoryModel,
      p be Property of M,
      a be Object of M,
      d be Point of M;
  pred
    a exemplifies_at p,d
  means
    [[a,d],p] in the exemplificationRelation of M;
  pred
    a encodes_at p,d
  means
    [[a,d],p] in the encodingRelation of M;
end;

definition
  let M be ObjectTheoryModel,
      p be Proposition of M;
  func
    lambda(p) -> Property of M
  means
    [p,it] in the abstractionOperation of M;
  existence;
::>       *4
  uniqueness;
::>        *4
end;

definition
  let M be ObjectTheoryModel,
      d be Point of M,
      p be Proposition of M;
  pred
    d validates p
  means
    :DefValidates:
    d encodes_at lambda(p),d;
end;

definition
  let M be ObjectTheoryModel;
  mode
    World of M -> Point of M
  means
    :DefWorld:
    ex d being Point of M st
      for p being Proposition of M holds
        (it encodes_at p,d iff p is_true_at it);
  existence;
::>       *4
end;

:: Concrete, ordinary and abstract objects
definition
  let M be ObjectTheoryModel,
      a be Object of M,
      d be Point of M;
  pred
    a is_concrete_at d
  means
    a in the concreteObjects of M;
end;

definition
  let M be ObjectTheoryModel,
      a be Object of M;
  attr
    a is ordinary
  means
    :DefOrdinary:
    ex w being World of M st a is_concrete_at w;
end;
    

notation
  let M be ObjectTheoryModel,
      a be Object of M;
  antonym a is abstract for a is ordinary;
end;

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Properties and propositions
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let M be ObjectTheoryModel;
  attr
    M is fully-abstract
  means
    :DefFullyAbstract:
    for x being Object of M holds x is abstract;
  attr
    M is fully-concrete
  means
    :DefFullyConcrete:
    for x being Object of M ex d being Point of M st x is_concrete_at d;
end;

registration
  cluster non fully-abstract ObjectTheoryModel;
  existence;
::>       *4
end;

registration
  cluster non fully-concrete ObjectTheoryModel;
  existence;
::>       *4
end;

registration
  let M be non fully-concrete ObjectTheoryModel;
  cluster abstract Object of M;
  existence;
::>       *4
end;

      

:: Appendix III: The Basic Theorems of World Theory

:: Definition of the makes-true relation

:: 1. There is a unique actual world

:: 2. Every world is maximal

:: 3. Every world is possible

:: 4. Every world is modally closed

:: 5. A proposition is necessarily true iff it is true at all possible
::    worlds

:: 6. A proposition is possible iff there is a world where it is true

:: 7. For any object x: a proposition p is true at world w if and only
:: if at w, x exemplifies being such that p

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: "A (Leibnizian) theory of concepts"
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Priciple 1
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

registration
  let M be non fully-abstract ObjectTheoryModel;
  cluster ordinary Object of M;
  existence;
::>       *4
end;

theorem
for M being non fully-abstract ObjectTheoryModel,
    a being ordinary Object of M,
    d being Point of M
  holds not (ex F being Property of M st a encodes_at F,d);
::>                                                      *4

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Principle 2, as a definition
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let M be ObjectTheoryModel,
      x, y be Object of M;
  pred x =E y
  means :DefConcreteEquality:
    for w being World of M,
        F being Property of M
      holds ( x exemplifies_at F,w iff y exemplifies_at F,w);
end;

:: Principle 3, as a scheme

:: We'll probably run into trouble with the absence of a contraint on
:: free variables.  But then again, we'd run into a trouble with
:: replacement, too, wouldn't we?  How do we skirt that issue?
scheme Principle3 { M() -> non fully-concrete ObjectTheoryModel,
                    P[Property of M()] } :
    ex x being abstract Object of M() st
      for w being World of M(), :: is this where the quantifier belongs?
          F being Property of M() holds (x encodes_at F,w iff P[F])
proof
  thus thesis;
::>         *4
end;

:: Principle 4, as a definition
definition
  let M be ObjectTheoryModel,
      x, y be Object of M;
  pred x =A y means
  :DefAbstractEquality:
  for w being World of M,
      F being Property of M
    holds (x encodes_at F,w iff y encodes_at F,w);
end;

:: Principle 5, as a definition
theorem
for M being ObjectTheoryModel,
    x, y being Object of M
  holds x = y iff (x =A y or y =E y);
::>                                *4,4,4

:: Principle 6, as a scheme
::
:: not sure how to represent this
::
:: scheme
::   Principle6 { M() -> ObjectTheoryModel, x,y() -> Object of M() }:
::     x = y
::   provided
::     :: ...

:: Logic of encoding
theorem
for M being ObjectTheoryModel,
    x being Object of M,
    F being Property of M
  st    (ex w  being World of M st    x encodes_at F,w)
  holds (for w being World of M holds x encodes_at F,w);
::>                                                   *4

::> 4: This inference is not accepted
